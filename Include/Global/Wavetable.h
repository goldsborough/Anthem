/*********************************************************************************************//*!
*
*  @file        Wavetable.h
*
*  @author      Peter Goldsborough
*
*  @date        25/09/2014
*
*  @brief       Wavetable management classes.
*
*  @details     This file defines the Wavetable class and the WavetableDB class.
*
*************************************************************************************************/

#ifndef __Anthem__Wavetable__
#define __Anthem__Wavetable__

#include <vector>

/*****************************************************************************//*!
*
*  Waveforms can be generated either purely mathematically through
*  various formulas or, in case of a square wave, simply by setting
*  half the wavetable to 1 and the other half to 0, thought this will
*  never come near to the complex waveforms found naturally. Of course
*  those can actually never be formed computationally, since most wave-
*  tables that occur naturally are made up of an uncountable number of
*  partials. However, we can get very close through additive approaches,
*  so by adding integer mutliples of the fundamental pitch in a variety
*  of ways:
*
*  Square wave: 2 - 64 partials
*
*                            _____       _____
*                           |     |     |     |
*                      _____|     |_____|     |_____
*
*  Square waves are generated by adding all the odd partials, so 3, 5, 7
*  etc. times the fundamental pitch. The amplitude is indirectly
*  proportinal to the partial number, so the third partial will be 1/3 the
*  amplitude, the 5th partial 1/5th and so on. 64 partials is the maximum
*  amount of partials we will compute here and is really more than enough
*  to get near a natural sound.
*
*  Sawtooth wave: 2 - 64 partials
*
*                             |\  |\  |\
*                             | \ | \ | \
*                             |  \|  \|  \
*
*  Sawtooth waves descend from maximum amplitude down to 0 linearly and then
*  jump right back. This is computed by adding all partials with indirectly
*  proportional amplitudes.
*
*  Ramp wave: 64 partials
*
*                                /|  /|  /|
*                               / | / | / |
*                              /  |/  |/  |
*
*  Ramp waves are somewhat the inverse of sawtooth waves in the way that
*  they ascend to maximum amplitude from 0, linearly again, and then jump
*  right back down. They are accomplished by using the same approach as
*  for saw waves but with all negative amplitude values.
*
*  Triangle wave: 64 Partials
*
*                              /\    /\    /\
*                             /  \  /  \  /  \
*                            /    \/    \/    \
*
*  Triangle waves can be seen as linear sine waves, or a combination of
*  ramp and saw waves. They ascend from 0 to 2 linearly and then descend
*  to 0 linearly again. They are created by adding all odd partials with
*  alternating sign for the amplitude.
*
*
*  More on this here: http://bit.ly/1nkyXfW
*
*
*  The wavetable must be initalized as _wtLength + 1, as we are using
*  linear interpolation. Say the current sample is sample 12345, at a table
*  length of 4096, the index increment per sample in the wavetable is
*  4096/44100 = 0.0928..., so the index for sample 12345 would be 1146.60....
*  This means that we must interpolate between index 1146 and index 1147.
*  Now, the table index for sample 44100 is 4096 of course, when doing
*  interpolation we would need to access item 4067. If we thus do not append
*  the beginning of the wave to the end, we get an index error.
*
*****************************************************************************/

/*********************************************************************************************//*!
*
*  @brief       A partial/harmonic/overtone.
*
*  @details     The Partial struct represents a single Partial for generating waveforms through
*               Fourier/Additive synthesis. A partial can be expressed through its number, an
*               integer multiple of the fundamental frequency, its amplitude and an optional
*               phase offset.
*
*************************************************************************************************/

struct Partial
{
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Partial object.
    *
    *  @param       number The Partial's number e.g. 2 means it has twice the frequency of the fundamental.
    *
    *  @param       ampl The initial amplitude value.
    *
    *  @param       phsOffs An optional initial phase offset in degrees, defaults to 0 (no offset).
    *
    *****************************************************************************************************/
    
    Partial(unsigned short number, double ampl, double phsOffs = 0)
    : num(number), amp(ampl), phaseOffs(phsOffs)
    { }
    
    /*! The Partial's number, stays const. */
    const unsigned short num;
    
    /*! The amplitude value. */
    double amp;
    
    /*! A phase offset */
    double phaseOffs;
};

/*********************************************************************************************//*!
*
*  @brief       Class for storing waveform lookup tables.
*
*  @details     This is the main class in Anthem for storing and looking up values from waveforms
*               (e.g. sine, saw, square wave). A wavetable can be constructed either by passing
*               it a pointer to waveform values directly or through Additive Synthesis, in
*               combination with the Partial struct. The Wavetable class implements reference
*               counting.
*
*************************************************************************************************/

class Wavetable
{
    
public:
    
    typedef unsigned long size_t;
    
    Wavetable()
    : _data(0), _size(0), _refptr(new size_t(1))
    { }
    
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Wavetable additively.
    *
    *  @details     An additive wavetable is constructed by adding a sequence of Partial objects
    *               together. Optionally they can smoothed out with sigma/lanczos approximation which
    *               also reduces the Gibbs effect.
    *
    *  @param       start An iterator to the start of a sequence of Partial objects (e.g. std::vector<Partial>).
    *
    *  @param       end An iterator to the end of a sequence of Partial objects.
    *
    *  @param       wtLen The length of the wavetable to construct, 4095 is used throughout Anthem.
    *
    *  @param       masterAmp Attenuation value for all values in the table.
    *
    *  @param       sigmaAprox Boolean whether or not to use sigma approximation to smooth out the values.
    *
    *  @param       bitWidth Number of bits to scale to, defaults to 16 (bits).
    *
    *****************************************************************************************************/
    
    template <class PartItr>
    Wavetable(PartItr start, PartItr end,
              size_t wtLength,
              double masterAmp = 1,
              bool sigmaAprox = false,
              unsigned int bitWidth = 16);
    
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Wavetable object from a pointer.
    *
    *  @param       ptr The pointer to waveform values to store and manage.
    *
    *  @param       wtLength The length of the wavetable (and the array of values pointed to by ptr).
    *
    *****************************************************************************************************/
    
    Wavetable(double * ptr, size_t wtLength)
    : _data(ptr), _size(wtLength), _refptr(new size_t(1))
    { }
    
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Wavetable object from another Wavetable.
    *
    *  @details     Because this class uses reference counting, the new Wavetable object will point to
    *               other's data. Call makeUnique() to create a copy of the data pointed to (after).
    *
    *  @param       other The other Wavetable object.
    *
    *****************************************************************************************************/
    
    Wavetable(const Wavetable& other);
    
    ~Wavetable();
    
    /*************************************************************************************************//*!
    *
    *  @brief       Makes the internal pointer point to other's data.
    *
    *  @details     Copying a Wavetable makes it point to other's data and destructs its data if it
    *               is the last class pointing to it. Use makeUnique() (after) to create a copy of the
    *               data pointed to.
    *
    *  @param       other The other Wavetable object.
    *
    *****************************************************************************************************/
    
    Wavetable& operator= (const Wavetable& other);
    
    double& operator[] (size_t ind);
    
    const double& operator[] (size_t ind) const;
    
    /*************************************************************************************************//*!
    *
    *  @brief       Interpolates values from a fractional index.
    *
    *  @details     This function returns a proportionate value from a fractional index. For example,
    *               passing it an index of 1.5 will return [1] + (([2] - [1]) * 0.5).
    *
    *  @param       ind The fractional index.
    *
    *****************************************************************************************************/
    
    double interpolate(double ind) const;
    
    /*! Returns the wavetable's size. */
    size_t size() const;
    
    /*! Returns the wavetable's data. */
    double* get() const;
    
    /*************************************************************************************************//*!
    *
    *  @brief       Makes a unique copy of the pointed-to data.
    *
    *  @details     The Wavetable class implements reference counting so constructing a new Wavetable
    *               object from an existing object will make both objects point to the same data. It
    *               may be required to make the data unique to an object at one point, for which this
    *               method exists. Note that calling the non-const operator[] also calls makeUnique().
    *
    *****************************************************************************************************/
    
    Wavetable& makeUnique();
    
private:
    
    /*! The pointed-to data */
    double* _data;
    
    /*! Current size of the wavetable. */
    size_t _size;
    
    /*! Pointer to the number of objects pointing to _data. */
    size_t* _refptr;
};

/*********************************************************************************************//*!
*
*  @brief       Stores Anthem's wavetables.
*
*  @details     The WavetableDB class manages all of Anthem's wavetables and is responsible for
*               providing Oscillators with Wavetables.
*
*************************************************************************************************/

class WavetableDB
{
    
public:
    
    /*! Standard wavetables */
    enum Wavetables
    {
        NONE = -1,
        
        SINE,
        SINE_2,
        SINE_4, // The number is the number of bits, not partials
        SINE_8,
        
        SQUARE, // with sigma
        SQUARE_2,
        SQUARE_4,
        SQUARE_8,
        SQUARE_16,
        SQUARE_32,
        SQUARE_64,
        
        SAW, // with sigma
        SAW_2,
        SAW_4,
        SAW_8,
        SAW_16,
        SAW_32,
        SAW_64,
        
        TRIANGLE,
        RAMP,
        
        DIRECT_TRI,
        DIRECT_SQUARE,
        DIRECT_SAW,
        
        SMOOTH_SQUARE,
        SMOOTH_SAW
    };
    
    /*********************************************************************************************//*!
    *
    *  @brief       Initialzes the WavetableDB.
    *
    *  @details     The WavetableDB is initialized by reading all available wavetables from the
    *               wavetable folder.
    *
    *************************************************************************************************/
    
    void init();
    
    Wavetable& operator[] (const int& wt);
    
    const Wavetable& operator[] (const int& wt) const;
    
private:
    
    /*! Generates a sawtooth wave directly/mathematically */
    Wavetable _directSaw();
    
    /*! Generates a square wave directly/mathematically */
    Wavetable _directSquare();
    
    /*! Generates a triangle wave directly/mathematically */
    Wavetable _directTriangle();
    
    /*! Generates a smoothed sawtooth wave directly/mathematically */
    Wavetable _smoothSaw();
    
    /*! Generates a smoothed square wave directly/mathematically */
    Wavetable _smoothSquare();
    
    std::vector<Wavetable> _tables;
};

// One global instance
extern WavetableDB wavetableDB;

#endif /* defined(__Anthem__Wavetable__) */
