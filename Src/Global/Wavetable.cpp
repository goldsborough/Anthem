//
//  Wavetable.cpp
//  Synth
//
//  Created by Peter Goldsborough on 22/03/14.
//  Copyright (c) 2014 Peter Goldsborough. All rights reserved.
//

#include "Wavetable.h"
#include "Global.h"
#include "Parser.h"
#include <iostream>

void Wavetable::Init(unsigned int wtLen)
{
    _wtLength = wtLen;
    _fundIncr = twoPI / _wtLength;
    
    _textParser = new TextParser("/Users/petergoldsborough/Documents/vibe/Resources/Wavetables/wavetables.txt");
    
    _wtNames = _textParser->readAll();
    
    for (int i = 0; i < _wtNames.size(); i++)
        _tables.push_back( _readWavetable(i) );
}

double * Wavetable::getWaveform(const int mode)
{
    if (mode < 0 || mode > _tables.size() - 1)
        throw std::out_of_range("Mode out of range");
    
    if (mode != NONE)
        return _tables[mode];
    
    return 0;
}


void Wavetable::round(double& val, unsigned int bitWidth)
{
    double factor = 1.0/bitWidth;
    
    std::vector<double> vec;
    
    // Fill vector with all possible values
    
    for (double i = -1.0; i <= 1.0; i += factor) vec.push_back(i);
    
    // Find the first value that is bigger than the current num,
    // then compute the midpoint between the current and the next
    // value and see whether it is is bigger than or smaller than
    // that and round appropriately
    
    for (uint32_t i = 0; i < vec.size() - 1; i++)
    {
        if (val <= vec[i + 1])
        {
            double mid = vec[i] + (factor/2);
            
            if (val < mid) val = vec[i];

            else val = vec[i + 1];

            break;
        }
    }
}

double* Wavetable::genWave(unsigned char wavID,
                           unsigned char partialNumber,
                           double ampFactor,
                           unsigned char bitWidth)
{
    /*
         Waveforms can be generated either purely mathematically through
         various formulas or, in case of a square wave, simply by setting
         half the wavetable to 1 and the other half to 0, thought this will
         never come near to the complex waveforms found naturally. Of course
         those can actually never be formed computationally, since most wave-
         _tables that occur naturally are made up of an uncountable number of
         partials. However, we can get very close through additive approaches,
         so by adding integer mutliples of the fundamental pitch in a variety of
         ways:
         
         Square wave: 2 - 64 partials
         
               _____       _____
              |     |     |     |
         _____|     |_____|     |_____
     
         Square waves are generated by adding all the odd partials, so 3, 5, 7
         etc. times the fundamental pitch. The amplitude is indirectly proportinal
         to the partial number, so the third partial will be 1/3 the amplitude, the
         5th partial 1/5th and so on. 64 partials is the maximum amount of partials
         we will compute here and is really more than enough to get near a natural
         sound.
         
         Sawtooth wave: 2 - 64 partials
         
         |\  |\  |\
         | \ | \ | \
         |  \|  \|  \
         
         Sawtooth waves descend from maximum amplitude down to 0 linearly and then
         jump right back. This is computed by adding all partials with indirectly
         proportional amplitudes.
         
         Ramp wave: 64 partials
         
           /|  /|  /|
          / | / | / |
         /  |/  |/  |
         
         Ramp waves are somewhat the inverse of sawtooth waves in the way that they
         ascend to maximum amplitude from 0, linearly again, and then jump right back
         down. They are accomplished by using the same approach as for saw waves but
         with all negative amplitude values.
         
         Triangle wave: 64 Partials
         
         Triangle waves can be seen as linear sine waves, or a combination of ramp and
         saw waves. They ascend from 0 to 2 linearly and then descend to 0 linearly again.
         They are created by adding all odd partials with alternating sign for the amplitude.
         
            /\    /\    /\
           /  \  /  \  /  \
          /    \/    \/    \
     
     
          The wavetable must be initalized as _wtLength + 1, as we are using linear interpolation.
          Say the current sample is sample 12345, at a table length of 4096, the index increment
          per sample in the wavetable is 4096/44100 = 0.0928..., so the index for sample 12345
          would be 1146.60.... This means that we must interpolate between index 1146 and index
          index 1147. Now, the table index for sample 44100 is 4096 of course, when doing interpolation
          we would need to access item 4067. If we thus do not append the beginning of the wave to the
          end, we get an index error.
     */
    
    unsigned int step;
    
    // SINE
    if (wavID == 0) step = 0;
    
    // SAW and RAMP
    else if (wavID == 2 || wavID == 3) step = 1;
    
    // TRIANGLE and SQUARE
    else step = 2;
    
    unsigned int partialTotal = partialNumber + 1;
    
    double* wt = new double [_wtLength + 1];
    
    // Allocate memory for partialNumber + 1 entries,
    // so also one for the fundamental frequency
    
    double * amp = new double [partialTotal];
    double * phase = new double [partialTotal];
    double * phase_incr = new double [partialTotal];
    
    unsigned int bitWidthBin = pow(2, bitWidth);
    int part = 1;

    /*
        Lanczos sigma constant to counteract the Gibbs
        phenomenon (the horns at the end of the waveforms,
        especially noticable with square waves). This thing
        is absolutely AMAZING for waves where you actually
        want the (non-mathematical) perfection, the problem
        is that it horrendously smooths out ALL waveforms,
        leading to waveforms with lower partial numbers to
        be smoothed out to almost linear segments. This is
        of course not wanted for example for a saw wave with
        two partials. You want the characteristic look of
        Fourier Synthesis. For this reason, I will only use
        the Lanczos Sigma factor for the waveforms with 64
        partials.
     
        It is calculated by:
     
        x = n * PI / M
     
        n being the current partial number and M the number
        of all partials. Then:
     
        sigma = sin(x) / x
    */
    
    // Constant part, PI / number of partials
    double sigmaK = PI/partialTotal;

    for (unsigned int p = 0; p < partialTotal; p++)
    {
        phase[p] = 0.0;
        phase_incr[p] = _fundIncr * part;
        
        if (wavID == 4) // Triangle
        {
            double val = 1.0/(part*part);
            
            // Change sign
            
            if (p > 0 && amp[p-1] > 0)
                amp[p] = -val;
            
            else
                amp[p] = val;
        }
        
        // Ramp wave
        else if (wavID == 3)
            amp[p] = -(1.0/part);
        
        // Sine and Square
        else
            amp[p] = 1.0/part;
        
        // Lanczos sigma factor
        if (partialNumber >= 64)
        {
            // constant part * the partial number
            double sigmaN = sigmaK * part;
            
            amp[p] *= sin(sigmaN)/sigmaN;
        }
        
        // Reduce amplitude with empirically determinded
        // factor to make range from 1 to -1 (would overflow
        // in case of ramp,tri and sawtooth wave otherwise)
        amp[p] *= ampFactor;
        
        part += step;
        
    }
    
    for (unsigned int n = 0; n < _wtLength; n++)
    {
        double value = 0.0;
        
        // Add all phases of all partials, including
        // that of the fundamental pitch to value
        
        for (unsigned int p = 0; p < partialTotal; p++)
        {
            value += sin(phase[p]) * amp[p];
            
            phase[p] += phase_incr[p];
            
            if (phase[p] >= twoPI)
                phase[p] -= twoPI;
        }
        
        if (bitWidth < 16) round(value, bitWidthBin);
        
        wt[n] = value;
    }
    
    // Append the last item for interpolation
    
    wt[_wtLength] = wt[0];
    
    delete [] phase;
    delete [] phase_incr;
    delete [] amp;
    
    return wt;
}

double* Wavetable::smoothSaw()
{
    double* wt = new double[_wtLength + 1];
    
    // First decrement from 1 to -1 in 9/10 of the cycle,
    // then go back up smoothly the last 1/10 of the cycle
    
    // The first part is calculated linearly so that the
    // amplitude simply decrements from 1 to -1. This is
    // measured in amplitude
    
    double amp = 1;
    
    // The second part is measured in time, going from 0.9
    // to 1 (of the wavetable period)
    
    double ind = 0.9;
    
    // Increment value from -1 to 1
    double ampIncr = 2.0/(_wtLength * 0.9);
    
    // Increment value for the time
    double indIncr = 0.1/(_wtLength * 0.1);
    
    for (unsigned int n = 0; n < _wtLength; n++)
    {
        if (amp > -1)
        {
            wt[n] = amp;
            
            // simply decrement
            amp -= ampIncr;
        }
        
        else
        {
            /*********************************************************************
             * The smooth transition is nothing else than a function I found
             * empirically in graphing software (GeoGebra). There are actually
             * two functions. The first increments from -1 to 0 (amp) from 0.9
             * to 0.95 (time). This function is positive and right-shifted 0.9.
             * This first function meets the second function in (0.95,0), which
             * is basically the same function but with negative coefficient and
             * right shifted by 1. It is best to put these functions in graphing
             * software to get a clear picture. In any case, these functions are
             * changed between so that from 0.9 to 0.95 the curvature is negative
             * so the function is progressive and the second part has a positive
             * curvature and is degressive.
             *********************************************************************/
            
            if (ind < 0.95)
                wt[n] = 400 * pow(ind - 0.9,2) - 1;
            
            else
                wt[n] = -400 * pow(ind - 1,2) + 1;
            
            ind += indIncr;
        }
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

double* Wavetable::smoothSquare()
{
    double* wt = new double[_wtLength + 1];
    
    double ind = 0;
    
    double incr = 1.0 / _wtLength;
    
    float exp = 50;

    for (unsigned int n = 0; n < _wtLength; n++)
    {
        double val;
        
        // Change the function every pi/2 radians,
        // each is a simple function of 50th degree
        // which is just a very square looking
        // quadratic function, when interleaved
        // like this, there are no sharp transitions
        // any longer!
        
        if (ind < 0.25)
            val = pow(ind - 1, exp) - 1;
        
        else if (ind < 0.5)
            val = pow(ind + 0.5, exp) - 1;
        
        else if (ind < 0.75)
            val = -pow(ind - 1.5, exp) + 1;
        
        else
            val = -pow(ind, exp) + 1;
        
        wt[n] = val;
        
        if ( (ind += incr) >= _wtLength)
            ind -= _wtLength;
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

double * Wavetable::directSquare()
{
    // the sample buffer
    double * wt = new double [_wtLength + 1];
    
    // time for one sample
    double sampleTime = 1.0 / _wtLength;
    
    // the midpoint of the period
    double mid = 0.5;
    
    double ind = 0;
    
    // fill the sample buffer
    for (int n = 0; n < _wtLength; n++)
    {
        wt[n] = (ind < mid) ? -1 : 1;
        
        if ( (ind += sampleTime) >= _wtLength)
            ind -= _wtLength;
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

double * Wavetable::directSaw()
{
    // the sample buffer
    double * wt = new double [_wtLength];
    
    // how much we must decrement the count
    // by at each iteration
    // 2.0 because the range is from 1 to -1
    double incr = 2.0 / _wtLength;
    
    double ind = 1;
    
    for (int n = 0; n < _wtLength; n++)
    {
        wt[n] = ind;
        
        if ( (ind -= incr) <= -1)
            ind = 1;
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

double* Wavetable::directTriangle()
{
    double* wt = new double[_wtLength + 1];
    
    double phase = 0;
    double phaseIncr = twoPI / _wtLength;
    
    // Basierend auf Pseudocode (vgl. Mitchell, 2008)
    
    double triValue;
    double twoDivPi = 2.0/PI;
    
    for (unsigned int n = 0; n < _wtLength; n++)
    {
        triValue = (phase * twoDivPi);
        
        if (phase < 0) triValue = 1.0 + triValue;
        
        else triValue = 1.0 - triValue;
        
        wt[n] = triValue;
        
        if ( (phase += phaseIncr) >= PI)
            phase -= twoPI;
        
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

double* Wavetable::genNoise()
{
    double * wt = new double[_wtLength + 1];
    
    for (unsigned int n = 0; n < _wtLength; n++)
    {
        /*
         // We subtract half the maximum range from the generated number
         // to get a range between - RAND_MAX / 2 and + RAND_MAX / 2, then
         // we divide by that range to get a value between -1 and 1, thus
         // normalized.
         */
        
        double randHalf = RAND_MAX/2.0;
        
        double value =  (rand() - randHalf) / randHalf;
        
        wt[n] = value;
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

double* Wavetable::genericWave(std::vector<Partial>& partials)
{
    
    double * wt = new double [_wtLength + 1];
    
    Partial fund;
    
    fund.number = 1;
    fund.amp = 1;

    fund.phase_incr = _fundIncr;
    
    partials.insert(partials.begin(), fund);
    
    for (unsigned int n = 0; n < _wtLength; n++)
    {
        double value = 0.0;
        
        for (std::vector<Partial>::iterator itr = partials.begin(), end = partials.end();
             itr != end;
             ++itr)
        {
            value += sin(itr->phase) * itr->amp;
            
            itr->phase += itr->phase_incr;
            
            if (itr->phase >= twoPI) itr->phase -= twoPI;
        }
        
        wt[n] = value;
        
    }
    
    wt[_wtLength] = wt[0];
    
    return wt;
    
}

double * Wavetable::_readWavetable(const int waveNum)
{
    double * wt = new double [_wtLength + 1];
    
    std::string fname = "/Users/petergoldsborough/Documents/vibe/Resources/Wavetables/" + _wtNames[waveNum] + ".vwt";
    
    std::ifstream inFile(fname);
    
    if (! inFile.good() || ! inFile.is_open() ||
        ! inFile.read(reinterpret_cast<char*>(wt), (_wtLength) * sizeof(*wt)) ) // this is part of the if clause
        throw std::runtime_error("Error reading wavetables!");
    
    wt[_wtLength] = wt[0];
    
    return wt;
}

Wavetable::~Wavetable()
{
     for (int i = 0; i < _tables.size(); i++)
         delete [] _tables[i];
    
    delete _textParser;
}