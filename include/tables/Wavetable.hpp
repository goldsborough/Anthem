/*********************************************************************************************//*!
*
*  @file        Wavetable.hpp
*
*  @author      Peter Goldsborough
*
*  @date        25/09/2014
*
*  @brief       Wavetable management classes.
*
*  @details     This file defines the Wavetable class and the WavetableDB class.
*
*************************************************************************************************/

#ifndef __Anthem__Wavetable__
#define __Anthem__Wavetable__

#include "LookupTable.hpp"
#include "Util.hpp"
#include "Global.hpp"

#include <cmath>
#include <string>
#include <vector>
#include <memory>

/*****************************************************************************//*!
*
*  Waveforms can be generated either purely mathematically through
*  various formulas or, in case of a square wave, simply by setting
*  half the wavetable to 1 and the other half to 0, thought this will
*  never come near to the complex waveforms found naturally. Of course
*  those can actually never be formed computationally, since most wave-
*  tables that occur naturally are made up of an uncountable number of
*  partials. However, we can get very close through additive approaches,
*  so by adding integer mutliples of the fundamental pitch in a variety
*  of ways:
*
*  Square wave: 2 - 64 partials
*
*                            _____       _____
*                           |     |     |     |
*                      _____|     |_____|     |_____
*
*  Square waves are generated by adding all the odd partials, so 3, 5, 7
*  etc. times the fundamental pitch. The amplitude is indirectly
*  proportional to the partial number, so the third partial will be 1/3 the
*  amplitude, the 5th partial 1/5th and so on. 64 partials is the maximum
*  amount of partials we will compute here and is really more than enough
*  to get near a natural sound.
*
*  Sawavetableooth wave: 2 - 64 partials
*
*                             |\  |\  |\
*                             | \ | \ | \
*                             |  \|  \|  \
*
*  Sawavetableooth waves descend from maximum amplitude down to 0 linearly and then
*  jump right back. This is computed by adding all partials with indirectly
*  proportional amplitudes.
*
*  Ramp wave: 64 partials
*
*                                /|  /|  /|
*                               / | / | / |
*                              /  |/  |/  |
*
*  Ramp waves are somewhat the inverse of sawavetableooth waves in the way that
*  they ascend to maximum amplitude from 0, linearly again, and then jump
*  right back down. They are accomplished by using the same approach as
*  for saw waves but with all negative amplitude values.
*
*  Triangle wave: 64 Partials
*
*                              /\    /\    /\
*                             /  \  /  \  /  \
*                            /    \/    \/    \
*
*  Triangle waves can be seen as linear sine waves, or a combination of
*  ramp and saw waves. They ascend from -1 to 1 linearly and then descend
*  to -1e linearly again. They are created by adding all odd partials with
*  alternating sign for the amplitude.
*
*
*  More on this here: http://bit.ly/1nkyXfW
*
*
*  The wavetable must be initalized as _wavetableLength + 1, as we are using
*  linear interpolation. Say the current sample is sample 12345, at a table
*  length of 4096, the index increment per sample in the wavetable is
*  4096/44100 = 0.0928..., so the index for sample 12345 would be 1146.60....
*  This means that we must interpolate between index 1146 and index 1147.
*  Now, the table index for sample 44100 is 4096 of course, when doing
*  interpolation we would need to access item 4067. If we thus do not append
*  the beginning of the wave to the end, we get an index error.
*
*****************************************************************************/

/*********************************************************************************************//*!
*
*  @brief       A partial/harmonic/overtone.
*
*  @details     The Partial struct represents a single Partial for generating waveforms through
*               Fourier/Additive synthesis. A partial can be expressed through its number, an
*               integer multiple of the fundamental frequency, its amplitude and an optional
*               phase offset.
*
*************************************************************************************************/

struct Partial
{
    /*! The Partial's number (freq = 
        number * fundamental frequency). */
    unsigned short number;
    
    /*! Its amplitude value. */
    double amp;
    
    /*! A phase offset */
    double phaseOffset;
};

/*********************************************************************************************//*!
*
*  @brief       Class for storing waveform lookup tables.
*
*  @details     This is the main class in Anthem for storing and looking up values from waveforms
*               (e.g. sine, saw, square wave). A wavetable can be constructed either by passing
*               it a pointer to waveform values directly or through Additive Synthesis, in
*               combination with the Partial struct. The Wavetable class implements reference
*               counting.
*
*************************************************************************************************/

class Wavetable : public LookupTable<double>
{
    
public:
    
    using index_t = unsigned short;
    
    enum class MathematicalWaveform
    {
        DIRECT_TRIANGLE,
        DIRECT_SQUARE,
        DIRECT_SAW,
        
        SMOOTH_SQUARE,
        SMOOTH_SAW,
        SMOOTH_RAMP
    };
    
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Wavetable additively.
    *
    *  @details     An additive wavetable is constructed by adding a sequence of Partial objects
    *               together. Optionally they can smoothed out with sigma/lanczos approximation which
    *               also reduces the Gibbs effect.
    *
    *  @param       begin An iterator to the begin of a sequence of Partial objects (e.g. std::vector<Partial>).
    *
    *  @param       end An iterator to the end of a sequence of Partial objects.
    *
    *  @param       wavetableLength The length of the wavetable to construct, 4095 is used throughout Anthem.
    *
    *  @param       masterAmp Attenuation value for all values in the table.
    *
    *  @param       sigmaAprox Boolean whether or not to use sigma approximation to smooth out the values.
    *
    *  @param       bitWidth Number of bits to scale to, defaults to 16 (bits).
    *
    *  @param       id The wavetable's id, defaults to -1.
    *
    *  @param       name An optional name for the Wavetable, as std::string.
    *
    *****************************************************************************************************/
    
    template <class PartialIterator>
    Wavetable(PartialIterator begin,
              PartialIterator end,
              index_t length,
              const std::string& id,
              double master = 1,
              bool sigma = false,
              unsigned int bits = 16)
    : LookupTable<double>(length, id)
    {
        // calculate number of partials
        index_t partials = std::distance(begin, end);
        
        double* amplitude = new double [partials];  // The amplitudes
        double* phase = new double [partials];      // The current phase
        double* increment = new double [partials];  // The phase increment
        
        /**********************************************************
        *
        *  The Lanczos sigma constant, a.k.a. sigma approximation,
        *  is a method of minimizing the effect of the Gibbs
        *  phenomenon, which leads to ripples and horns towards the
        *  ends of additively synthesized waveforms. It is defined
        *  as:
        *
        *  s = sin(x) / x
        *
        *  Where x is:
        *
        *  x = nπ / M
        *
        *  M being the total number of partials and n the current
        *  partial number (the fundamental frequency is seen as
        *  the first partial). π / M can be calculated
        *  loop-invariantly and is then mulitplied by each partial
        *  number, respectively.
        *
        **********************************************************/
        
        // constant sigma part
        double sigmaK = Global::pi / partials;
        
        // variable part
        double sigmaV;
        
        // convert the bit width to decimal
        // A bit width of n bits gives ± 2^n-1
        // possible values the samples can assume
        bits = pow(2, bits - 1);
        
        // the fundamental increment of one period in radians
        static double fundIncr = Global::twoPi / length;
        
        // fill the arrays with the respective partial values
        for (index_t p = 0; begin != end; ++p, ++begin)
        {
            // initial phase
            phase[p] = begin->phaseOffset;
            
            // fundIncr is two π / tablelength
            increment[p] = fundIncr * begin->number;
            
            // reduce amplitude if necessary
            amplitude[p] = begin->amp * master;
            
            // apply sigma approximation conditionally
            if (sigma)
            {
                // following the formula
                sigmaV = sigmaK * begin->number;
                
                amplitude[p] *= sin(sigmaV) / sigmaV;
            }
        }
        
        // fill the wavetable
        for (auto& sample : data_)
        {
            // do additive magic
            for (unsigned short p = 0; p < partials; p++)
            {
                sample += sin(phase[p]) * amplitude[p];
                
                phase[p] += increment[p];
                
                if (phase[p] >= Global::twoPi)
                { phase[p] -= Global::twoPi; }
            }
            
            // Round to nearest value according to bitwidth
            if (bits < 32768) Util::round(sample, bits);
        }
        
        // Append the first item as last.
        // The global wavetable length is
        // one less than actual wavetable
        // length, because interpolation
        // requires an adjacent value for
        // the last valid wavetable index,
        // so the first is re-used.
        data_.push_back(*data_.begin());
        
        delete [] phase;
        delete [] increment;
        delete [] amplitude;
    }
    
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Wavetable object from a pointer.
    *
    *  @param       ptr The pointer to waveform values to store and manage.
    *
    *  @param       wavetableLength The length of the wavetable (and the array of values pointed to by ptr).
    *
    *  @param       id The wavetable's id, defaults to 0.
    *
    *  @param       name An optional name for the Wavetable, as std::string.
    *
    *****************************************************************************************************/
    
    Wavetable(double* data,
              index_t wavetableLength,
              const std::string& id);
    
    /*************************************************************************************************//*!
    *
    *  @brief       Constructs a Wavetable object with a directly calculated, mathematical waveform.
    *
    *  @param       waveform A MathematicalWaveform member to generate.
    *
    *  @param       wavetableLength The length of the wavetable (and the array of values pointed to by ptr).
    *
    *  @param       id The wavetable's id, defaults to -1.
    *
    *  @param       name An optional name for the Wavetable, as std::string.
    *
    *****************************************************************************************************/
    
    Wavetable(MathematicalWaveform waveform,
              index_t wavetableLength,
              const std::string& id);
    
private:
    
    /*! Generates a sawavetableooth wave directly/mathematically */
    void mathematicalSaw_();
    
    /*! Generates a square wave directly/mathematically */
    void mathematicalSquare_();
    
    /*! Generates a triangle wave directly/mathematically */
    void mathematicalTriangle_();
    
    /*! Generates a smoothed sawavetableooth wave directly/mathematically */
    void smoothSaw_();
    
    /*! Generates a smoothed ramp wave directly/mathematically */
    void smoothRamp_();
    
    /*! Generates a smoothed square wave directly/mathematically */
    void smoothSquare_();
};

/*********************************************************************************************//*!
*
*  @brief       Stores Anthem's wavetables.
*
*  @details     The WavetableDatabase class manages all of Anthem's wavetables
*               and is responsible for providing Oscillators with Wavetables.
*
*************************************************************************************************/

class WavetableDatabase
{
    
public:
    
    enum Wavetables
    {
        SINE,
        SINE_3,
        SINE_4, // The number is the number of bits, not partials
        SINE_8,
        
        SQUARE, // with sigma
        SQUARE_2,
        SQUARE_4,
        SQUARE_8,
        SQUARE_16,
        SQUARE_32,
        SQUARE_64,
        
        SAW, // with sigma
        SAW_2,
        SAW_4,
        SAW_8,
        SAW_16,
        SAW_32,
        SAW_64,
        
        TRIANGLE,
        
        RAMP, // with sigma
        RAMP_2,
        RAMP_4,
        RAMP_8,
        RAMP_16,
        RAMP_32,
        RAMP_64,
        
        DIRECT_TRIANGLE,
        DIRECT_SQUARE,
        DIRECT_SAW,
        
        SMOOTH_SQUARE,
        SMOOTH_SAW,
        SMOOTH_RAMP
    };
    
    typedef unsigned short index_t;
    
    /*********************************************************************************************//*!
    *
    *  @brief       Initialzes the WavetableDatabase.
    *
    *  @details     The WavetableDatabase is initialized by reading all available wavetables from the
    *               wavetable folder.
    *
    *************************************************************************************************/
    
    void init();
    
    std::shared_ptr<Wavetable>& operator[] (index_t wavetable);
    
    const std::shared_ptr<Wavetable>& operator[] (index_t wavetable) const;
    
    /*************************************************************************//*!
    *
    *   @brief Writes Wavetable object to file.
    *
    *   @param name The name of the wavetable.
    *
    *   @param wavetable The wavetable object to write to file. 
    *
    *   @param addToDefault Whether or not the WT should be loaded at begin-up.
    *
    ****************************************************************************/
    
    void writeWavetable(const std::string& name,
                        const Wavetable& wavetable,
                        bool addToDefaults = true) const;
    
    /*! Returns the number of wavetables stored. */
    index_t size() const;
    
private:
    
    /*************************************************************************//*!
    *
    *   @brief Reads a wavetable and returns a double pointer.
    *
    *   @param name The name of the wavetable.
    *
    ****************************************************************************/
    
    double* readWavetable_(const std::string& name) const;
    
    /*! Vector of Wavetable objects */
    std::vector<std::shared_ptr<Wavetable>> tables_;
};

extern WavetableDatabase wavetableDatabase;

#endif /* defined(__Anthem__Wavetable__) */
